// https://leetcode.com/problems/xor-queries-of-a-subarray

#include <vector>
#include <cstdio>
#include <cassert>

using namespace std;

class Solution {
public:
    friend class SolutionTest;

    vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {
        vector<int> prefixXorVec = buildPrefixXorVec(arr);

        int len = arr.size();
        vector<int> result;

        for (auto query: queries) {
            int startIdx = query[0];
            int endIdx = query[1];

            if (startIdx < 0 || endIdx >= len) {
                result.push_back(-1);
                continue;
            }

            int prefXorToRemove = (startIdx == 0) ? 0 : prefixXorVec[startIdx - 1];
            result.push_back(prefXorToRemove ^ prefixXorVec[endIdx]);
        }

        return result;
    }

private:
    // this method was auto generated by Amazon Q
    int calcXorForRange(vector<int>& arr, int startIdx, int endIdx) {
        if (arr.empty() || startIdx > endIdx || startIdx < 0 || endIdx >= arr.size()) {
            return 0;
        }

        int result = 0;
        for (int i = startIdx; i <= endIdx; i++) {
            result ^= arr[i];
        }
        return result;
    }

    // this method was modified on top of method auto-generated by Amazon Q
    vector<int> buildPrefixXorVec(vector<int> vec) {
        if (vec.empty()) {
            return {};
        }

        int len = vec.size();
        vector<int> prefixXorVec(len);
        prefixXorVec[0] = vec[0];

        for (int i = 1; i < len; i++) {
            prefixXorVec[i] = prefixXorVec[i - 1] ^ vec[i];
        }

        return prefixXorVec;
    }

    // this method was auto-generated by Amazon Q
    vector<int> buildSuffixXorVec(vector<int> vec) {
        if (vec.empty()) {
            return {};
        }

        int len = vec.size();
        vector<int> suffixXorVec(len);
        suffixXorVec[len - 1] = vec[len - 1];

        for (int i = len - 2; i >= 0; i--) {
            suffixXorVec[i] = suffixXorVec[i + 1] ^ vec[i];
        }

        return suffixXorVec;
    }
};

class SolutionTest {
public:
    void testXorQueries() {
        Solution soln = Solution();
        vector<int> vec;
        vector<vector<int>> queries;
        vector<int> outExpected, outComputed;

        vec = {1, 3, 4, 8};
        queries = {{0, 1},
                   {1, 2},
                   {0, 3},
                   {3, 3}};
        outExpected = {2, 7, 14, 8};
        outComputed = soln.xorQueries(vec, queries);
        assert(outExpected == outComputed);

        vec = {4, 8, 2, 10};
        queries = {{2, 3},
                   {1, 3},
                   {0, 0},
                   {0, 3}};
        outExpected = {8, 0, 4, 4};
        outComputed = soln.xorQueries(vec, queries);
        assert(outExpected == outComputed);

        printf("testXorQueries: all tests passed!\n");
    }

    void testCalcXorForRange() {
        Solution soln = Solution();
        vector<int> vec;
        int startIdx, endIdx;
        int outExpected, outComputed;

        vec = {};
        startIdx = 0;
        endIdx = 0;
        outExpected = 0;
        outComputed = soln.calcXorForRange(vec, startIdx, endIdx);
        assert(outExpected == outComputed);

        vec = {4};
        startIdx = 0;
        endIdx = 0;
        outExpected = 4;
        outComputed = soln.calcXorForRange(vec, startIdx, endIdx);
        assert(outExpected == outComputed);

        vec = {4, 6};
        startIdx = 0;
        endIdx = 0;
        outExpected = 4;
        outComputed = soln.calcXorForRange(vec, startIdx, endIdx);
        assert(outExpected == outComputed);

        vec = {4, 6};
        startIdx = 1;
        endIdx = 1;
        outExpected = 6;
        outComputed = soln.calcXorForRange(vec, startIdx, endIdx);
        assert(outExpected == outComputed);

        vec = {4, 6};
        startIdx = 0;
        endIdx = 1;
        outExpected = 2;
        outComputed = soln.calcXorForRange(vec, startIdx, endIdx);
        assert(outExpected == outComputed);

        printf("testCalcXorForRange: all tests passed!\n");
    }

    // this test-method was auto generated by Amazon Q
    void testBuildPrefixXorVec() {
        Solution soln = Solution();
        vector<int> vec;
        vector<int> outExpected, outComputed;

        vec = {};
        outExpected = {};
        outComputed = soln.buildPrefixXorVec(vec);
        assert(outExpected == outComputed);

        vec = {4};
        outExpected = {4};
        outComputed = soln.buildPrefixXorVec(vec);
        assert(outExpected == outComputed);

        vec = {4, 6};
        outExpected = {4, 2};
        outComputed = soln.buildPrefixXorVec(vec);
        assert(outExpected == outComputed);

        vec = {4, 6, 8};
        outExpected = {4, 2, 10};
        outComputed = soln.buildPrefixXorVec(vec);
        assert(outExpected == outComputed);

        printf("testBuildPrefixXorVec: all tests passed!\n");
    }

    // this test-method was auto generated by Amazon Q
    void testBuildSuffixXorVec() {
        Solution soln = Solution();
        vector<int> vec;
        vector<int> outExpected, outComputed;

        vec = {};
        outExpected = {};
        outComputed = soln.buildSuffixXorVec(vec);
        assert(outExpected == outComputed);

        vec = {4};
        outExpected = {4};
        outComputed = soln.buildSuffixXorVec(vec);
        assert(outExpected == outComputed);

        vec = {4, 6};
        outExpected = {2, 6};
        outComputed = soln.buildSuffixXorVec(vec);
        assert(outExpected == outComputed);

        vec = {4, 6, 8};
        outExpected = {10, 14, 8};
        outComputed = soln.buildSuffixXorVec(vec);
        assert(outExpected == outComputed);

        printf("testBuildSuffixXorVec: all tests passed!\n");
    }
};

int main() {
    SolutionTest solTest = SolutionTest();

    solTest.testXorQueries();
    solTest.testCalcXorForRange();
    solTest.testBuildPrefixXorVec();
    solTest.testBuildSuffixXorVec();

    return 0;
}
