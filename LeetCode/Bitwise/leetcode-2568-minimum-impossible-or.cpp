// LeetCode-2568: https://leetcode.com/problems/minimum-impossible-or
// DeepCodes: https://www.youtube.com/watch?v=29hNb_3EyPs

/**
 * Space: O(n); with some effort can be minimized to O(1)
 * Time: O(n)
 *
 * Idea: thinking about bitwise OR operations we see that
 * 1. essentially every number is formed by bitwise OR of some powers of
 * 2. given powers of two: 2^0, 2^1, 2^2 .. 2^(n-1), using bitwise ORs we
 *    can form every number up till (2^n) - 1. So then the first number we
 *    can NOT form would be 2^n.
 *
 * From above observations the task boils down to simply
 * finding the first power of 2 missing from the input array.
 */

#include <vector>
#include <unordered_set>

using namespace std;

#define MIN_EXP 0
#define MAX_EXP 31

class Solution {
private:
    // unused function
    inline bool isPowerOfTwo(int num) {
        // following line was auto-generated by Amazon CodeWhisperer
        return (num & (num - 1)) == 0;
    }

    inline unordered_set<int> convertToSet(vector<int>& vec) {
        unordered_set<int> mSet(vec.begin(), vec.end());
        return mSet;
    }

    inline bool setContains(unordered_set<int>& mSet, int num) {
        return mSet.find(num) != mSet.end();
    }

public:
    int minImpossibleOR(vector<int>& nums) {
        unordered_set<int> mSet = convertToSet(nums);

        for (int exp = MIN_EXP; exp < MAX_EXP; exp++) {
            int crrPow2 = 1 << exp;
            if (!setContains(mSet, crrPow2)) {
                return crrPow2;
            }
        }

        return INT_MIN;
    }
};
