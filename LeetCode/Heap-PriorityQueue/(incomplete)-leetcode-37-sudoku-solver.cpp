// LeetCode-37: https://leetcode.com/problems/sudoku-solver/
// incomplete

#include <vector>
#include <unordered_set>
#include <set>
#include <iostream>
#include <utility>
#include <cassert>
#include <cstdio>

using namespace std;

auto comparator = [](const pair <int, pair <int, int>>& p1, const pair <int, pair <int, int>>& p2) {
    return (p1.first <= p2.first);
};

class Solution {
private:
    int sideLength;
    vector <vector <int>> board;
    vector <vector <unordered_set <int>>> possibleValuesBoard;
    set <pair <int, pair <int, int>>, decltype(comparator)> pQue{comparator};

    vector <vector <int>> convertToIntBoard(vector <vector <char>>& charBoard) {
        vector <vector <int>> intBoard(sideLength, vector <int>(sideLength, 0));
        for (int i = 0; i < sideLength; i++) {
            for (int j = 0; j < sideLength; j++) {
                if (charBoard[i][j] == '.') {
                    intBoard[i][j] = -1;
                } else {
                    intBoard[i][j] = charBoard[i][j] - '0';
                }
            }
        }
        return intBoard;
    }

    vector <vector <char>> convertToCharBoard(vector <vector <int>>& intBoard) {
        vector <vector <char>> charBoard(sideLength, vector <char>(sideLength, '.'));
        for (int i = 0; i < sideLength; i++) {
            for (int j = 0; j < sideLength; j++) {
                if (intBoard[i][j] == -1) {
                    charBoard[i][j] = '.';
                } else {
                    charBoard[i][j] = intBoard[i][j] + '0';
                }
            }
        }
        return charBoard;
    }

    void createEmptyPossibleValuesBoard() {
        vector <vector <unordered_set <int>>> possibleValuesBoard(sideLength);
        for (int i = 0; i < sideLength; i++) {
            vector <unordered_set <int>> row = vector <unordered_set <int>>(sideLength);
            possibleValuesBoard[i] = row;
        }
        this->possibleValuesBoard = possibleValuesBoard;
    }

    // auto generated by Amazon-Q
    unordered_set <int> findPossibleValues(int row, int col) {
        unordered_set <int> possibleValues = {1, 2, 3, 4, 5, 6, 7, 8, 9};

        // eliminate possibilities by looking at cells of same column
        for (int i = 0; i < 9; i++) {
            if (board[row][i] <= 0) {
                continue;
            }

            possibleValues.erase(board[row][i]);
        }

        // eliminate possibilities by looking at cells of same row
        for (int i = 0; i < 9; i++) {
            if (board[i][col] <= 0) {
                continue;
            }

            possibleValues.erase(board[i][col]);
        }

        // eliminate possibilities by looking at cells of same square
        int boxRow = (row / 3) * 3;
        int boxCol = (col / 3) * 3;
        for (int i = boxRow; i < boxRow + 3; i++) {
            for (int j = boxCol; j < boxCol + 3; j++) {
                if (board[i][j] <= 0) {
                    continue;
                }

                possibleValues.erase(board[i][j]);
            }
        }

        return possibleValues;
    }

    void updatePossibleValues(int row, int col) {
        unordered_set <int> currentPossibleValues = possibleValuesBoard[row][col];
        pQue.erase({static_cast <int>(currentPossibleValues.size()), {row, col}});

        unordered_set <int> updatedPossibleValues = findPossibleValues(row, col);
        possibleValuesBoard[row][col] = updatedPossibleValues;
        pQue.insert({static_cast <int>(updatedPossibleValues.size()), {row, col}});
    }

    void fillPossibleValuesBoard() {
        for (int i = 0; i < sideLength; i++) {
            for (int j = 0; j < sideLength; j++) {
                if (this->board[i][j] == -1) {
                    updatePossibleValues(i, j);

                    // unordered_set <int> possibleValues = findPossibleValues(i, j);
                    // possibleValuesBoard[i][j] = possibleValues;
                    // pQue.insert({static_cast<int>(possibleValues.size()), {i, j}});
                }
            }
        }
    }

    void init(vector <vector <char>>& charBoard) {
        this->sideLength = charBoard.size();
        this->board = convertToIntBoard(charBoard);

        createEmptyPossibleValuesBoard();
        printf("came here");
        fillPossibleValuesBoard();
    }

    void updateNeighbouringPossibleValues(int row, int col) {
        // eliminate possibilities by looking at cells of same column
        for (int i = 0; i < 9; i++) {
            if (board[row][i] > 0) {
                continue;
            }

            updatePossibleValues(row, i);
        }

        // eliminate possibilities by looking at cells of same row
        for (int i = 0; i < 9; i++) {
            if (board[i][col] > 0) {
                continue;
            }

            updatePossibleValues(row, i);
        }

        // eliminate possibilities by looking at cells of same square
        int boxRow = (row / 3) * 3;
        int boxCol = (col / 3) * 3;
        for (int i = boxRow; i < boxRow + 3; i++) {
            for (int j = boxCol; j < boxCol + 3; j++) {
                if (board[i][j] > 0) {
                    continue;
                }

                updatePossibleValues(row, i);
            }
        }
    }

    bool solveSudoku() {
        while (!pQue.empty()) {
            pair <int, pair <int, int>> p = *pQue.begin();
            if (p.first > 1) {
                // no deterministic solution
                return false;
            }

            pQue.erase(pQue.begin());
            int row = p.second.first;
            int col = p.second.second;

            if (board[row][col] != -1) {
                // already filled (should never happen)
                pQue.insert({static_cast <int>(possibleValuesBoard[row][col].size()), {row, col}});
                continue;
            }

            unordered_set <int> possibleValues = possibleValuesBoard[row][col];
            if (possibleValues.size() > 1) {
                // duplicate of earlier check (p.first > 1)
                return false;
            }

            // fill value
            this->board[row][col] = *(possibleValues.begin());
            this->possibleValuesBoard[row][col] = {};

            updateNeighbouringPossibleValues(row, col);
        }

        return true;
    }

public:
    void solveSudoku(vector <vector <char>>& board) {
        printf("came here 1");
        init(board);

        if (solveSudoku()) {
            board = convertToCharBoard(this->board);
        } else {
            // no solution
        }
    }
};

class SolutionTest {
public:
    void testSolveSudoku() {
        Solution soln = Solution();
        vector <vector <char>> board;
        vector <vector <char>> boardOutExpected;

        board = {
            {'5', '3', '.', '.', '7', '.', '.', '.', '.'},
            {'6', '.', '.', '1', '9', '5', '.', '.', '.'},
            {'.', '9', '8', '.', '.', '.', '.', '6', '.'},
            {'8', '.', '.', '.', '6', '.', '.', '.', '3'},
            {'4', '.', '.', '8', '.', '3', '.', '.', '1'},
            {'7', '.', '.', '.', '2', '.', '.', '.', '6'},
            {'.', '6', '.', '.', '.', '.', '2', '8', '.'},
            {'.', '.', '.', '4', '1', '9', '.', '.', '5'},
            {'.', '.', '.', '.', '8', '.', '.', '7', '9'}
        };
        boardOutExpected = {
            {'5', '3', '4', '6', '7', '8', '9', '1', '2'},
            {'6', '7', '2', '1', '9', '5', '3', '4', '8'},
            {'1', '9', '8', '3', '4', '2', '5', '6', '7'},
            {'8', '5', '9', '7', '6', '1', '4', '2', '3'},
            {'4', '2', '6', '8', '5', '3', '7', '9', '1'},
            {'7', '1', '3', '9', '2', '4', '8', '5', '6'},
            {'9', '6', '1', '5', '3', '7', '2', '8', '4'},
            {'2', '8', '7', '4', '1', '9', '6', '3', '5'},
            {'3', '4', '5', '2', '8', '6', '1', '7', '9'}
        };
        printf("came here 1");
        soln.solveSudoku(board);
        assert(board == boardOutExpected);
    }
};

int main() {
    printf("came here -1\n");
    SolutionTest testObj = SolutionTest();
    printf("came here 0");

    testObj.testSolveSudoku();

    return 0;
}
