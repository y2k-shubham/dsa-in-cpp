// LeetCode-1343: https://leetcode.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold

// a micro-optimization would be that for each subarray (sliding-window) we only calculate and compare the required 'sum' instead of average.
// that ways we would save on n-k division operations

#include <vector>
#include <cassert>
#include <numeric>

using namespace std;

class Solution {
private:
    // generated by Amazon Q
    int sumFirstK(const std::vector<int>& vec, int k) {
        return accumulate(vec.begin(), vec.begin() + min(k, static_cast<int>(vec.size())), 0);
    }

public:
    friend class SolutionTest;

    int numOfSubarrays(vector<int>& arr, int k, int threshold) {
        int len = arr.size();

        if (threshold <= 1) {
            return len - k + 1;
        }

        int numSubarrays = 0;

        int crrSum = sumFirstK(arr, k);
        float crrAvg = crrSum / static_cast<float>(k);
        if (crrAvg >= threshold) {
            numSubarrays++;
        }

        for (int i = 1; (i + k - 1) < len; i++) {
            crrSum -= arr[i - 1];
            crrSum += arr[i + k - 1];

            crrAvg = crrSum / static_cast<float>(k);
            if (crrAvg >= threshold) {
                numSubarrays++;
            }
        }

        return numSubarrays;
    }
};

class SolutionTest {
public:
    void testNumOfSubarrays() {
        Solution soln = Solution();
        vector<int> vecIn;
        int kIn, thresholdIn;
        int numSubarraysOutExpected, numSubarraysOutComputed;

        vecIn = {2, 2, 2, 2, 5, 5, 5, 8};

        kIn = 3;
        thresholdIn = 4;
        numSubarraysOutExpected = 3;
        numSubarraysOutComputed = soln.numOfSubarrays(vecIn, kIn, thresholdIn);
        assert(numSubarraysOutExpected == numSubarraysOutComputed);

        kIn = 3;
        thresholdIn = 5;
        numSubarraysOutExpected = 2;
        numSubarraysOutComputed = soln.numOfSubarrays(vecIn, kIn, thresholdIn);
        assert(numSubarraysOutExpected == numSubarraysOutComputed);

        kIn = 3;
        thresholdIn = 6;
        numSubarraysOutExpected = 1;
        numSubarraysOutComputed = soln.numOfSubarrays(vecIn, kIn, thresholdIn);
        assert(numSubarraysOutExpected == numSubarraysOutComputed);

        kIn = 3;
        thresholdIn = 7;
        numSubarraysOutExpected = 0;
        numSubarraysOutComputed = soln.numOfSubarrays(vecIn, kIn, thresholdIn);
        assert(numSubarraysOutExpected == numSubarraysOutComputed);

        kIn = 4;
        thresholdIn = 2;
        numSubarraysOutExpected = 5;
        numSubarraysOutComputed = soln.numOfSubarrays(vecIn, kIn, thresholdIn);
        assert(numSubarraysOutExpected == numSubarraysOutComputed);

        kIn = 4;
        thresholdIn = 3;
        numSubarraysOutExpected = 3;
        numSubarraysOutComputed = soln.numOfSubarrays(vecIn, kIn, thresholdIn);
        assert(numSubarraysOutExpected == numSubarraysOutComputed);

        kIn = 4;
        thresholdIn = 4;
        numSubarraysOutExpected = 2;
        numSubarraysOutComputed = soln.numOfSubarrays(vecIn, kIn, thresholdIn);
        assert(numSubarraysOutExpected == numSubarraysOutComputed);

        kIn = 4;
        thresholdIn = 5;
        numSubarraysOutExpected = 1;
        numSubarraysOutComputed = soln.numOfSubarrays(vecIn, kIn, thresholdIn);
        assert(numSubarraysOutExpected == numSubarraysOutComputed);

        kIn = 4;
        thresholdIn = 6;
        numSubarraysOutExpected = 0;
        numSubarraysOutComputed = soln.numOfSubarrays(vecIn, kIn, thresholdIn);
        assert(numSubarraysOutExpected == numSubarraysOutComputed);

        vecIn = {11, 13, 17, 23, 29, 31, 7, 5, 2, 3};

        kIn = 3;
        thresholdIn = 5;
        numSubarraysOutExpected = 6;
        numSubarraysOutComputed = soln.numOfSubarrays(vecIn, kIn, thresholdIn);
        assert(numSubarraysOutExpected == numSubarraysOutComputed);

        printf("[testNumOfSubarrays] All test cases passed\n");
    }
};

int main() {
    SolutionTest solnTest = SolutionTest();

    solnTest.testNumOfSubarrays();

    return 0;
}
