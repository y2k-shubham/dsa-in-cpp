// http://www.geeksforgeeks.org/convert1-a-given-binary-tree-to-doubly-linked-list-set-2/

/*

Explanation of input format
>> check the input format, it's given in comments on top of the program.
>> it says keep entering values to be inserted into tree along with their position in the tree, till -1 is entered for either value or position.
>> here position is 1-indexed, so root has position 1, root -> left has position 2, root -> right has position 3, root -> left -> left has position 4 and so on.
>> the tree need not be complete binary tree but all successive insertion positions should be legal)

*/

/*
What the tree generated by this input will look like:
			     1
        2                 3
	4       5         6       7
   8 9   10  11        13   14
	    20  22          27
				         55

Input (copy till -1 -1)
1 1
2 2		3 3
4 4		5 5		6 6		7 7
8 8		9 9		10 10	11 11	13 13	14 14
20 20	22 22	27 27
55 55
-1 -1
*/

/*
Explanation
in the code populate-inorder-successor-for-all-nodes.cpp, we had used *crr as pointer to current
node in inOrder traversal and **prev as double pointer to inOrder predecessor of current node.
just like that question, **prev will enable us to link left of *crr to it's inOrder predecessor.
so all left links to doubly linked list can be created in this way

but here, we also require the inOrder successor of the current node so as to make connections
to right pointer of current node to it's inOrder successor. but inOrder successor cannot be had
the same way as inOrder predecessor (**prev) because while we can update *prev before moving to
another node, the same can't be done with **next as it needs to stay ahead of the crr node.

so we use the observation that if we continue to use the pointers *crr and **prev, we can say
that just as *prev is inOrder predecessor of crr, crr is inOrder successor of *prev. so we just
need to make an extra connection (yes that means just 1 more line to be added to recursive
method) to accomplish this. bazinga!

when the recursive method will get over, we would still have our *root pointing to the node
which was the root of the binary tree. we then have to traverse backwards to get head of linked
list and forwards to get tail of the linked list so as to display it in normal and reverse order
a little optimization can be done here by making the recursive method return the head of the
linked list.
*/

#include <cstdio>
#include <iostream>

using namespace std;

struct node {
	int val;
	struct node * left;
	struct node * right;
};


void inOrder(node *);
node * createNode(int);
node * getPath(int);
void showList(node *, const char *);
void showListRev(node *, const char *);
node * insert(node *, node *, node *);
node * findHead(node *);
node * findTail(node *);
node * convert1(node *, node **);
void convert2(node *, node **);
void convert3(node *, node **, node **, node **);

int main() {
	node * root;
	node * head, * tail;
	int val, pos;

	printf("\nEnter (val, pos) to insert into BST:-\n(pos starts from 1)\n");
	scanf("%d%d", &val, &pos);

	root = NULL;
	while (val != -1 && pos != -1) {
		node * path = getPath(pos);
		root = insert(root, path -> right, createNode(val));

		scanf("%d%d", &val, &pos);
	}

	printf("\nThe inOrder traversal is:-\n");
	inOrder(root);
	printf("\n");

	node * tmp = createNode(-1);

	// Method 1
//	head = convert1(root, &tmp);
//
//	head -> right -> left = NULL;
//	head = head -> right;
//	showList(head, "forward linkedlist");
//
//	tail = findTail(root);
//	showListRev(tail, "reverse linkedList");

	// Method 2
//	convert2(root, &tmp);
//
//	head = findHead(root);
//	showList(head, "forward link list");
//
//	tail = findTail(head);
//	showListRev(tail, "reverse link list");

	// Method 3
	head = createNode(-1);
	tail = createNode(-1);

	node ** head2 = &head;
	node ** tail2 = &tail;

	convert3(root, &tmp, head2, tail2);

	showList(*head2, "forward link list");
	showListRev(*tail2, "reverse link list");

	return 0;
}

node * createNode(int val) {
	node * newNode = new node;

	newNode -> val = val;
	newNode -> left = NULL;
	newNode -> right = NULL;

	return newNode;
}

void inOrder(node * root) {
	if (root != NULL) {
		inOrder(root -> left);
		printf("%d ", root -> val);
		inOrder(root -> right);
	}
}

node * getPath(int val) {
	node * head;

	head = createNode(val);
	val /= 2;

	while (val >= 1) {
		node * newNode = createNode(val);
		newNode -> right = head;
		head = newNode;

		val /= 2;
	}

	return head;
}

void showList(node * head, const char * msg) {
	printf("\nThe %s is:-\n", msg);
	for (node * list = head; list != NULL; list = list -> right) {
		printf("%d -> ", list -> val);
	}
	printf("NULL\n");
}

void showListRev(node * head, const char * msg) {
	printf("\nThe %s is:-\n", msg);
	for (node * list = head; list != NULL; list = list -> left) {
		printf("%d -> ", list -> val);
	}
	printf("NULL\n");
}

node * insert(node * root, node * path, node * newNode) {
	if (path == NULL) {
		return newNode;
	} else {
		if (path -> val % 2 == 1) {
			root -> right = insert(root -> right, path -> right, newNode);
		} else {
			root -> left = insert(root -> left, path -> right, newNode);
		}

		return root;
	}
}

node * findHead(node * tmp) {
	while (tmp != NULL && tmp -> left != NULL) {
		tmp = tmp -> left;
	}
	return tmp;
}

node * findTail(node * tmp) {
	while (tmp != NULL && tmp -> right != NULL) {
		tmp = tmp -> right;
	}
	return tmp;
}

node * convert1(node * crr, node ** prev) {
	if (crr != NULL) {
		// convert1 the left subtree and receive the head
		node * head = convert1(crr -> left, prev);

		// to initialize the head of linked list when first node of the tree should be printed
		if ((*prev) -> val == -1) {
			head = crr;
		}

		// make connections for doubly-linked list
		(*prev) -> right = crr;
		crr -> left = (*prev);
		(*prev) = crr;

		// convert1
		convert1(crr -> right, prev);

		if (head != NULL) {
			return head;
		} else {
			// necessary because if the root node has no left subtree, then the root node itself
			// will become the head of linked list
			return crr;
		}
	} else {
		return NULL;
	}
}

void convert2(node * root, node ** prev) {
	if (root != NULL) {
		convert2(root -> left, prev);

		(*prev) -> right = root;
		if ((*prev) -> val != -1) {
			root -> left = *prev;
		}
		*prev = root;

		convert2(root -> right, prev);
	}
}

void convert3(node * root, node ** prev, node ** head, node ** tail) {
	if (root != NULL) {
		convert3(root -> left, prev, head, tail);

		(*prev) -> right = root;
		if ((*prev) -> val != -1) {
			root -> left = *prev;
		} else {
			*head = root;
		}
		*prev = root;
		*tail = root;

		convert3(root -> right, prev, head, tail);
	}
}

